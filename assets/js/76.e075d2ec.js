(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{430:function(v,e,n){"use strict";n.r(e);var _=n(20),t=function(v){v.options.__data__block__={mermaid_382ee1e9:"graph LR;\n\nW(外部 HTTP:80 请求) --\x3e N80(HTTP:80)\n\nsubgraph Nginx 外部监听\nN80 -.- N301(301转写) -.- N443(HTTPS:443)\nend\n\nN443 --\x3e X(Xray 监听 443) .- X1{入站判断}\nX1 --\x3e |接收 VLESS 流量| X2(Xray内部规则)\nX2 --\x3e O(Xray Outbounds 出站)\nX1 ==> |回落 非VLESS 流量| N8080(Nginx:8080)\nN8080:::nginxclass ==> H(index.html)\n\nH:::nginxclass\nclassDef nginxclass fill:#FFFFDE\n\n",mermaid_64a56832:"graph LR;\n\nW443(外部 HTTP:443 请求) --\x3e X443(Xray-inbound: 443) .- X1{入站判断}\nX1 --\x3e |协议 = VLESS 的流量| X2(Xray内部规则)\nX2 --\x3e O(Xray Outbounds 出站)\n\nX1 --\x3e |path = /websocket 的流量| X1234(Xray-inbound:1234)\nX1 --\x3e |path = /vmesstcp 的流量| X2345(Xray-inbound:2345)\nX1 --\x3e |path = /vmessws 的流量| X3456(Xray-inbound:3456)\nX1 --\x3e |其它所有流量| X1310(Xray-inbound:1310)\n\n",mermaid_64a5619e:"    graph LR;\n\n    W443(外部 HTTP:443 请求) --\x3e X443(Xray-inbound: 443) .- X1{入站判断}\n    X1 --\x3e |协议 = VLESS 的流量| X2(Xray内部规则)\n    X2 --\x3e XO(Xray Outbounds 出站)\n\n    X1 --\x3e |path = /websocket 的流量| X1234(Xray-inbound:1234)\n    X1 --\x3e |path = /vmesstcp 的流量| X2345(Xray-inbound:2345)\n    X1 --\x3e |path = /vmessws 的流量| X3456(Xray-inbound:3456)\n    X1 --\x3e |其它所有流量| X1310(Xray-inbound:1310)\n\n    X1234 --\x3e X2\n    X2345 --\x3e X2\n    X3456 --\x3e X2\n\n    X1310 --\x3e |协议 = trojan 的流量| X2\n    X1310 --\x3e |其他所有流量| N80(Nginx:80)\n\n    N80:::nginxclass --\x3e H(index.html)\n\n    H:::nginxclass\n    classDef nginxclass fill:#FFFFDE\n"}},a=Object(_.a)({},(function(){var v=this,e=v.$createElement,n=v._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("h1",{attrs:{id:"回落-fallbacks-功能简析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回落-fallbacks-功能简析"}},[v._v("#")]),v._v(" 回落 (fallbacks) 功能简析")]),v._v(" "),n("p",[v._v("在使用 Xray 的过程中，你一定无数次的听说了【回落】这个功能。本文就稍微说明一下这个功能的逻辑以及使用方式。")]),v._v(" "),n("h2",{attrs:{id:"_1-回顾《小小白白话文》中的回落"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-回顾《小小白白话文》中的回落"}},[v._v("#")]),v._v(" 1. 回顾《小小白白话文》中的回落")]),v._v(" "),n("p",[v._v("如果你用了《小小白白话文》中的"),n("RouterLink",{attrs:{to:"/document/level-0/ch07-xray-server.html#_7-4-配置xray"}},[v._v("Xray 配置")]),v._v("，并完成了"),n("RouterLink",{attrs:{to:"/document/level-0/ch07-xray-server.html#_7-8-服务器优化之二-开启http自动跳转https"}},[v._v("HTTP 自动跳转 HTTPS 优化")]),v._v("，那么你已经有了基于 "),n("code",[v._v("VLESS")]),v._v(" 协议的简易回落：")],1),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('"inbounds": [\n    {\n        "port": 443,\n        "protocol": "vless",\n        "settings": {\n            "clients": [\n                ...\n            ],\n            "decryption": "none",\n            "fallbacks": [\n                {\n                    "dest": 8080 // 默认回落到防探测的代理\n                }\n            ]\n        },\n        "streamSettings": {\n            ...\n        }\n    }\n]\n')])])]),n("p",[v._v("这一段配置用人话要怎么解释呢？")]),v._v(" "),n("ol",[n("li",[n("p",[n("strong",[n("code",[v._v("Xray")]),v._v(" 的入站端口 "),n("code",[v._v("[inbound port]")]),v._v(" 是 "),n("code",[v._v("443")])])]),v._v(" "),n("p",[v._v("即由 "),n("code",[v._v("Xray")]),v._v(" 负责监听 "),n("code",[v._v("443")]),v._v(" 端口的 "),n("code",[v._v("HTTPS")]),v._v(" 流量")])]),v._v(" "),n("li",[n("p",[n("strong",[n("code",[v._v("Xray")]),v._v(" 的入站协议 "),n("code",[v._v("[inbound protocol]")]),v._v(" 是 "),n("code",[v._v("vless")])])]),v._v(" "),n("p",[v._v("只有 "),n("code",[v._v("vless")]),v._v(" 协议的流量才会流入 "),n("code",[v._v("Xray")]),v._v(" 中做后续处理。")]),v._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),n("p",[n("strong",[v._v("注：")]),v._v(" "),n("code",[v._v("VLESS")]),v._v(" 这个轻量协议开发的初衷就是给 "),n("code",[v._v("xray")]),v._v(" 及 "),n("code",[v._v("v2fly")]),v._v(" 等核心引入回落功能、并同时减少冗余校验/加密。（当然，到目前为止，"),n("code",[v._v("xray")]),v._v(" 中的 "),n("code",[v._v("trojan")]),v._v(" 协议也已完整支持回落功能。）")])])]),v._v(" "),n("li",[n("p",[n("strong",[v._v("回落目标端口 "),n("code",[v._v("[fallback dest]")]),v._v(" 是 "),n("code",[v._v("8080")])])]),v._v(" "),n("p",[n("code",[v._v("Xray")]),v._v(" 接受 "),n("code",[v._v("443")]),v._v(" 端口的访问流量后，属于 "),n("code",[v._v("vless")]),v._v(" 协议的流量、由 "),n("code",[v._v("Xray")]),v._v(" 进行内部处理并转发至出站模块。而其他非 "),n("code",[v._v("vless")]),v._v(" 协议的流量，则转发至 "),n("code",[v._v("8080")]),v._v(" 端口。")]),v._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),n("p",[n("strong",[v._v("问：到底是单数还是复数？")])]),v._v(" "),n("p",[v._v("答：一定有聪明的同学发现，配置文件中，明明是复数 "),n("code",[v._v("inbounds")]),v._v(", "),n("code",[v._v("fallbacks")]),v._v("，为什么我解释的时候都是单数："),n("code",[v._v("inbound")]),v._v(", "),n("code",[v._v("fallback")]),v._v(" 呢？")]),v._v(" "),n("p",[v._v("因为，配置文件中用复数，说明 "),n("code",[v._v("xray")]),v._v(" 支持 N 个同等级的元素（即 N 个入站，M 个回落等等），上面的示例解析中仅仅是其中一个，所以我用了单数。")])])]),v._v(" "),n("li",[n("p",[n("strong",[v._v("回落给 "),n("code",[v._v("8080")]),v._v(" 端口的流量，由后续程序处理")])]),v._v(" "),n("p",[v._v("小小白白话文中的示例，就是 "),n("code",[v._v("8080")]),v._v(" 端口由 "),n("code",[v._v("Nginx")]),v._v(" 处理，根据配置找到并展示小熊猫的网页。")])]),v._v(" "),n("li",[n("p",[n("strong",[v._v("总结，小小白白话文示例中的最简单回落，完整数据路线如下：")])]),v._v(" "),n("Mermaid",{attrs:{id:"mermaid_382ee1e9",graph:v.$dataBlock.mermaid_382ee1e9}})],1)]),v._v(" "),n("h2",{attrs:{id:"_2-重新认识回落-what-how-v1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-重新认识回落-what-how-v1"}},[v._v("#")]),v._v(" 2. 重新认识回落 (WHAT, HOW "),n("code",[v._v("v1")]),v._v(")")]),v._v(" "),n("p",[v._v("基于上面的示例，你应该就可以明白什么是回落（What）和怎么回落（How）了，简单地说就是下面这几个要素：")]),v._v(" "),n("ol",[n("li",[v._v("回落的时间是流量进入 "),n("code",[v._v("Xray监听端口")]),v._v(" 后")]),v._v(" "),n("li",[v._v("回落的依据是 "),n("code",[v._v("协议类型")]),v._v(" 等流量特征")]),v._v(" "),n("li",[v._v("回落的目标是某个 "),n("code",[v._v("端口")])]),v._v(" "),n("li",[v._v("被回落的流量由监听 "),n("code",[v._v("回落端口")]),v._v(" 的后续程序接手")])]),v._v(" "),n("h2",{attrs:{id:"_3-为什么要回落-why-v1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么要回落-why-v1"}},[v._v("#")]),v._v(" 3. 为什么要回落 (WHY "),n("code",[v._v("v1")]),v._v(")")]),v._v(" "),n("p",[v._v("最初，是为了防御 "),n("strong",[v._v("【主动探测】")]),v._v(" (Active Probing)")]),v._v(" "),n("p",[n("strong",[v._v("主动探测：")]),v._v(" 简单粗暴的理解，就是指外部通过发送特定的网络请求，并解读服务器的回应内容，来推测服务器端是否运行了 "),n("code",[v._v("xray")]),v._v(", "),n("code",[v._v("v2fly")]),v._v(", "),n("code",[v._v("shadowsocks")]),v._v(" 等代理工具。一旦可以准确认定，则服务器可能受到干扰或阻断。")]),v._v(" "),n("p",[v._v("之所以可以根据服务器回应内容进行解读，就是因为一次完整的数据请求，其实有很多数据交换的步骤，每一个步骤，都会产生一些软件特征。用大白话说就是：")]),v._v(" "),n("ul",[n("li",[v._v("正常的网站的回应，一定【会有】类似 "),n("code",[v._v("Nginx")]),v._v(", "),n("code",[v._v("Apache")]),v._v(", "),n("code",[v._v("MySQL")]),v._v(" 的 Web 服务、数据库等工具的特征")]),v._v(" "),n("li",[v._v("正常的网站的回应，一定【不会有】类似 "),n("code",[v._v("xray")]),v._v(", "),n("code",[v._v("v2fly")]),v._v(", "),n("code",[v._v("shadowsocks")]),v._v(" 等代理工具的特征")])]),v._v(" "),n("p",[v._v("于是，当我们给 "),n("code",[v._v("Xray")]),v._v(" 提供了【回落】功能后（如上例，回落给 "),n("code",[v._v("Nginx")]),v._v("），面对任何用来探测的请求，产生的结果是：")]),v._v(" "),n("ul",[n("li",[v._v("探测流量无法掌握你的 "),n("code",[v._v("VLESS")]),v._v(" 要素，故都会被回落至 "),n("code",[v._v("Nginx")])]),v._v(" "),n("li",[v._v("探测流量全都回落进入 "),n("code",[v._v("Nginx")]),v._v(" ，故 VPS 服务器的回应一定【会有】 "),n("code",[v._v("Nginx")]),v._v(" 的特征")]),v._v(" "),n("li",[v._v("因为 "),n("code",[v._v("Xray")]),v._v(" 本身不对探测流量做任何回应 ，所以 VPS 的回应一定【不会有】 "),n("code",[v._v("Xray")]),v._v(" 的特征")])]),v._v(" "),n("p",[v._v("至此，【回落】功能就从数据交互逻辑上解决了服务器被 "),n("strong",[v._v("【主动探测】")]),v._v(" 的安全隐患。")]),v._v(" "),n("h2",{attrs:{id:"_4-重新认识【回落の完全体】-what-why-how-v2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-重新认识【回落の完全体】-what-why-how-v2"}},[v._v("#")]),v._v(" 4. 重新认识【回落の完全体】 (WHAT, WHY, HOW "),n("code",[v._v("v2")]),v._v(")")]),v._v(" "),n("p",[v._v("为什么又要再次认识回落呢？ 因为，上面仅仅说清楚了基于“协议”的、抵抗【主动探测】的初版回落。")]),v._v(" "),n("p",[v._v("在 "),n("a",{attrs:{href:"https://github.com/rprx",target:"_blank",rel:"noopener noreferrer"}},[v._v("rprx"),n("OutboundLink")],1),v._v(" 不断开发迭代 "),n("code",[v._v("VLESS")]),v._v(" 协议及 "),n("code",[v._v("fallback")]),v._v(" 功能的过程种，逐渐发现，回落完全可以更加灵活强大，只要在保证抵抗【主动探测】的前提下，充分利用数据首包中的信息，其实可以做到多元素、多层次的回落。（如 "),n("code",[v._v("path")]),v._v(", "),n("code",[v._v("alpn")]),v._v(" 等）")]),v._v(" "),n("p",[v._v("基于这个开发理念，【回落】功能才逐渐成长为现在的完全体，即完成了 "),n("code",[v._v("纯伪装 --\x3e ws分流 --\x3e 多协议多特征分流")]),v._v(" 的进化。最终版甚至完全替代了以前要用 Web 服务器、其他工具才能完成的分流的功能。且由于上述的【回落/分流】处理都在首包判断阶段以毫秒级的速度完成、不涉及任何数据操作，所以几乎没有任何过程损耗。")]),v._v(" "),n("p",[n("strong",[v._v("因此，现在 "),n("code",[v._v("Xray")]),v._v(" 中【完整体的回落功能】，同时具备下述属性：")])]),v._v(" "),n("ul",[n("li",[n("strong",[v._v("安全：")]),v._v(" 充分抵御主动探测攻击")]),v._v(" "),n("li",[n("strong",[v._v("高效：")]),v._v(" 几乎毫无性能损失")]),v._v(" "),n("li",[n("strong",[v._v("灵活：")]),v._v(" 数据灵活分流、常用端口复用（如 443）")])]),v._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[v._v("啰嗦君")]),v._v(" "),n("p",[v._v("这样多轮介绍虽然略显繁琐，但只有这样层层深入展开，才能充分的说明【回落の完全体】独有的强大！")])]),v._v(" "),n("h2",{attrs:{id:"_5-多层回落示例及解读"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-多层回落示例及解读"}},[v._v("#")]),v._v(" 5. 多层回落示例及解读")]),v._v(" "),n("p",[v._v("理解了【回落の完全体】是什么，那就可以动手操作配置多层回落了。其实，项目已经提供了非常完整的示例，即官方模板中的 "),n("a",{attrs:{href:"https://github.com/XTLS/Xray-examples/blob/main/VLESS-TCP-XTLS-WHATEVER/",target:"_blank",rel:"noopener noreferrer"}},[v._v("VLESS-TCP-XTLS-WHATEVER"),n("OutboundLink")],1),v._v("。")]),v._v(" "),n("h3",{attrs:{id:"_5-1-首先-我将服务器端配置的-443-监听段摘抄如下"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-首先-我将服务器端配置的-443-监听段摘抄如下"}},[v._v("#")]),v._v(" 5.1 首先，我将服务器端配置的 443 监听段摘抄如下：")]),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('{\n    "port": 443,\n    "protocol": "vless",\n    "settings": {\n        "clients": [\n            {\n                    "id": "", // 填写你的 UUID\n                    "flow": "xtls-rprx-direct",\n                    "level": 0,\n                    "email": "love@example.com"\n            }\n        ],\n        "decryption": "none",\n        "fallbacks": [\n            {\n                "dest": 1310, // 默认回落到 Xray 的 Trojan 协议\n                "xver": 1\n            },\n            {\n                "path": "/websocket", // 必须换成自定义的 PATH\n                "dest": 1234,\n                "xver": 1\n            },\n            {\n                "path": "/vmesstcp", // 必须换成自定义的 PATH\n                "dest": 2345,\n                "xver": 1\n            },\n            {\n                "path": "/vmessws", // 必须换成自定义的 PATH\n                "dest": 3456,\n                "xver": 1\n            }\n        ]\n    },\n    "streamSettings": {\n        "network": "tcp",\n        "security": "xtls",\n        "xtlsSettings": {\n            "alpn": [\n                "http/1.1"\n            ],\n            "certificates": [\n                {\n                    "certificateFile": "/path/to/fullchain.crt", // 换成你的证书，绝对路径\n                    "keyFile": "/path/to/private.key" // 换成你的私钥，绝对路径\n                }\n            ]\n        }\n    }\n},\n')])])]),n("p",[v._v("这一段配置用人话要怎么解释呢？")]),v._v(" "),n("ol",[n("li",[n("p",[n("strong",[n("code",[v._v("Xray")]),v._v(" 的入站端口 ("),n("code",[v._v("inbound port")]),v._v(") 是 "),n("code",[v._v("443")])])]),v._v(" "),n("p",[v._v("即由 "),n("code",[v._v("Xray")]),v._v(" 负责监听 "),n("code",[v._v("443")]),v._v(" 端口的 "),n("code",[v._v("HTTPS")]),v._v(" 流量，并使用 "),n("code",[v._v("certificates")]),v._v(" 项下设定的 "),n("code",[v._v("TLS")]),v._v(" 证书来进行验证")])]),v._v(" "),n("li",[n("p",[n("strong",[n("code",[v._v("Xray")]),v._v(" 的入站协议 ("),n("code",[v._v("inbound protocol")]),v._v(") 是 "),n("code",[v._v("vless")])])]),v._v(" "),n("p",[n("code",[v._v("vless")]),v._v(" 协议流量直接流入 "),n("code",[v._v("Xray")]),v._v(" 中做后续处理")])]),v._v(" "),n("li",[n("p",[n("strong",[v._v("非 "),n("code",[v._v("VLESS")]),v._v(" 协议流量有 4 个不同的回落目标：")])]),v._v(" "),n("ol",[n("li",[n("code",[v._v("path")]),v._v(" 为 "),n("code",[v._v("websocket")]),v._v(" 的流量，回落给端口 "),n("code",[v._v("1234")]),v._v(" 后续处理")]),v._v(" "),n("li",[n("code",[v._v("path")]),v._v(" 为 "),n("code",[v._v("vmesstcp")]),v._v(" 的流量，回落给端口 "),n("code",[v._v("2345")]),v._v(" 后续处理")]),v._v(" "),n("li",[n("code",[v._v("path")]),v._v(" 为 "),n("code",[v._v("vmessws")]),v._v(" 的流量，回落给端口 "),n("code",[v._v("3456")]),v._v(" 后续处理")]),v._v(" "),n("li",[v._v("其它所有流量，回落给端口 "),n("code",[v._v("1310")]),v._v(" 后续处理")])])]),v._v(" "),n("li",[n("p",[n("strong",[n("code",[v._v("xver")]),v._v(" 为 "),n("code",[v._v("1")]),v._v(" 表示开启 "),n("code",[v._v("proxy protocol")]),v._v(" 功能，向后传递来源真实 IP")])])]),v._v(" "),n("li",[n("p",[n("strong",[v._v("上述回落结构如下图所示：")])]),v._v(" "),n("Mermaid",{attrs:{id:"mermaid_64a56832",graph:v.$dataBlock.mermaid_64a56832}})],1),v._v(" "),n("li",[n("p",[n("strong",[v._v("网页回落不见了！")])]),v._v(" "),n("p",[v._v("没错，聪明的同学应该发现了，防御【主动探测】的 "),n("code",[v._v("nginx回落")]),v._v(" 不见了！！！这是为什么呢？会不会不安全？别急，我们继续分析：")])])]),v._v(" "),n("h3",{attrs:{id:"_5-2-后续监听处理的配置段摘抄如下"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-后续监听处理的配置段摘抄如下"}},[v._v("#")]),v._v(" 5.2 后续监听处理的配置段摘抄如下：")]),v._v(" "),n("ol",[n("li",[n("p",[v._v("后续处理回落至 "),n("code",[v._v("1310")]),v._v(" 端口的流量，按照下面的配置验证、处理：")]),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('{\n    "port": 1310,\n    "listen": "127.0.0.1",\n    "protocol": "trojan",\n    "settings": {\n        "clients": [\n            {\n                "password": "", // 填写你的密码\n                "level": 0,\n                "email": "love@example.com"\n            }\n        ],\n        "fallbacks": [\n            {\n                "dest": 80 // 或者回落到其它也防探测的代理\n            }\n        ]\n    },\n    "streamSettings": {\n        "network": "tcp",\n        "security": "none",\n        "tcpSettings": {\n            "acceptProxyProtocol": true\n        }\n    }\n},\n')])])]),n("p",[v._v("看，神奇的事情发生了， "),n("code",[v._v("trojan")]),v._v(" 协议这里又出现了一个新的 "),n("code",[v._v("fallbacks")]),v._v("。前面已经说过，"),n("code",[v._v("xray")]),v._v(" 中的 "),n("code",[v._v("trojan")]),v._v(" 协议也具有完整的回落能力，所以，此时 "),n("code",[v._v("trojan")]),v._v(" 协议可以再次做判断和回落（这也就是传说中的套娃回落了）：")]),v._v(" "),n("ul",[n("li",[v._v("所有 "),n("code",[v._v("trojan")]),v._v(" 协议的流量，流入 "),n("code",[v._v("Xray")]),v._v(" 中做后续处理")]),v._v(" "),n("li",[v._v("所有非 "),n("code",[v._v("trojan")]),v._v(" 协议的流量，转发至 "),n("code",[v._v("80")]),v._v(" 端口，【主动探测】的防御，完成！")])])]),v._v(" "),n("li",[n("p",[v._v("后续处理回落至 "),n("code",[v._v("1234")]),v._v(" 端口的流量，仔细看！它其实是 "),n("code",[v._v("vless+ws")]),v._v("：")]),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('{\n    "port": 1234,\n    "listen": "127.0.0.1",\n    "protocol": "vless",\n    "settings": {\n        "clients": [\n            {\n                "id": "", // 填写你的 UUID\n                "level": 0,\n                "email": "love@example.com"\n            }\n        ],\n        "decryption": "none"\n    },\n    "streamSettings": {\n        "network": "ws",\n        "security": "none",\n        "wsSettings": {\n            "acceptProxyProtocol": true, // 提醒：若你用 Nginx/Caddy 等反代 WS，需要删掉这行\n            "path": "/websocket" // 必须换成自定义的 PATH，需要和分流的一致\n        }\n    }\n},\n')])])])]),v._v(" "),n("li",[n("p",[v._v("后续处理回落至 "),n("code",[v._v("2345")]),v._v(" 端口的流量，仔细看！它其实是 "),n("code",[v._v("vmess直连")]),v._v("：")]),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('{\n    "port": 2345,\n    "listen": "127.0.0.1",\n    "protocol": "vmess",\n    "settings": {\n        "clients": [\n            {\n                "id": "", // 填写你的 UUID\n                "level": 0,\n                "email": "love@example.com"\n            }\n        ]\n    },\n    "streamSettings": {\n        "network": "tcp",\n        "security": "none",\n        "tcpSettings": {\n            "acceptProxyProtocol": true,\n            "header": {\n                "type": "http",\n                "request": {\n                    "path": [\n                        "/vmesstcp" // 必须换成自定义的 PATH，需要和分流的一致\n                    ]\n                }\n            }\n        }\n    }\n},\n')])])])]),v._v(" "),n("li",[n("p",[v._v("后续处理回落至 "),n("code",[v._v("3456")]),v._v(" 端口的流量，再仔细看！它其实是是 "),n("code",[v._v("vmess+ws(+cdn)")]),v._v("。")]),v._v(" "),n("div",{staticClass:"custom-block warning"},[n("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),n("p",[n("strong",[v._v("说明：")]),v._v(" 你没看错，这就是 v2fly 曾经的推荐组合之一，并可完整支持 "),n("code",[v._v("CDN")]),v._v("。现已加入完美回落套餐哦！")])]),v._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[v._v('{\n    "port": 3456,\n    "listen": "127.0.0.1",\n    "protocol": "vmess",\n    "settings": {\n        "clients": [\n            {\n                "id": "", // 填写你的 UUID\n                "level": 0,\n                "email": "love@example.com"\n            }\n        ]\n    },\n    "streamSettings": {\n        "network": "ws",\n        "security": "none",\n        "wsSettings": {\n            "acceptProxyProtocol": true, // 提醒：若你用 Nginx/Caddy 等反代 WS，需要删掉这行\n            "path": "/vmessws" // 必须换成自定义的 PATH，需要和分流的一致\n        }\n    }\n}\n')])])])]),v._v(" "),n("li",[n("p",[v._v("至此，我们就能够完整的画出模板的回落路线了：")])])]),v._v(" "),n("Mermaid",{attrs:{id:"mermaid_64a5619e",graph:v.$dataBlock.mermaid_64a5619e}}),n("h2",{attrs:{id:"_6-结语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-结语"}},[v._v("#")]),v._v(" 6. 结语")]),v._v(" "),n("p",[v._v("至此，"),n("code",[v._v("Xray")]),v._v(" 的【回落】功能就介绍完了。希望本文能够对你理解 "),n("code",[v._v("Xray")]),v._v(" 的强大有所帮助。")]),v._v(" "),n("h2",{attrs:{id:"_7-附加题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-附加题"}},[v._v("#")]),v._v(" 7. 附加题")]),v._v(" "),n("p",[v._v("我再无耻的留一个附加题：本文详解的 "),n("a",{attrs:{href:"https://github.com/XTLS/Xray-examples/blob/main/VLESS-TCP-XTLS-WHATEVER/",target:"_blank",rel:"noopener noreferrer"}},[v._v("VLESS-TCP-XTLS-WHATEVER"),n("OutboundLink")],1),v._v(" 模板？是否有可以优化的地方？")]),v._v(" "),n("p",[v._v("提示：HTTP 自动跳转 HTTPS")])],1)}),[],!1,null,null,null);"function"==typeof t&&t(a);e.default=a.exports}}]);